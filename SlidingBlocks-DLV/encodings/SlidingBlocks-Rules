%SE HAI UN BLOCCO TIPO 0 1x1
canMoveDown(ID):-blocco(0,ID, X, Y, W, H),empty(K,Y),K=X+H.
canMoveUp(ID):-blocco(0,ID, X, Y, W, H),empty(K,Y),K=X-H.
canMoveLeft(ID):-blocco(0,ID, X, Y, W, H),empty(X,K),K=Y-W.
canMoveRight(ID):-blocco(0,ID, X, Y, W, H),empty(X,K),K=Y+W.

%SE HAI UN BLOCCO TIPO 1 1x2
canMoveDown(ID):-blocco(1,ID, X, Y, W, H),empty(K,Y),K=X+H.
canMoveUp(ID):-blocco(1,ID, X, Y, W, H),empty(K,Y),K=X-1.
canMoveLeft(ID):-blocco(1,ID, X, Y, W, H),I=Y-1,J=X+1,empty(X,I),empty(J,I).
canMoveRight(ID):-blocco(1,ID, X, Y, W, H),empty(X,J),empty(I,J),I=X+1,J=Y+1.

%SE HAI UN BLOCCO TIPO 2 2x1
canMoveLeft(ID):-blocco(2,ID, X, Y, W, H),empty(X,J),J=Y-1.
canMoveRight(ID):-blocco(2,ID, X, Y, W, H),empty(X,J),J=Y+W.
canMoveDown(ID):-blocco(2,ID, X, Y, W, H),empty(I,Y),empty(I,J),I=X+1,J=Y+1.
canMoveUp(ID):-blocco(2,ID, X, Y, W, H),empty(I,Y),empty(I,J),I=X-1,J=Y+1.

%SE HAI UN BLOCCO TIPO 3 2x2
canMoveLeft(ID):-blocco(3,ID, X, Y, W, H),I=Y-1,J=X+1,empty(X,I),empty(J,I).
canMoveRight(ID):-blocco(3,ID, X, Y, W, H),empty(X,J),empty(I,J),I=X+1,J=Y+1.
canMoveDown(ID):-blocco(3,ID, X, Y, W, H),empty(I,Y),empty(I,J),I=X+1,J=Y+1.
canMoveUp(ID):-blocco(3,ID, X, Y, W, H),empty(I,Y),empty(I,J),I=X-1,J=Y+1.

%Guess DATO UN BLOCCO DA POTER SPOSTARE, O LO SPOSTO O NON LO SPOSTO. DIREZIONE: 1lEFT-2RIGHT-3DOWN-4UP.
move(X,1)|notMove(X):-canMoveLeft(X).
move(X,2)|notMove(X):-canMoveRight(X).
move(X,3)|notMove(X):-canMoveDown(X).
move(X,4)|notMove(X):-canMoveUp(X).
:-#count{X:move(X,_)}>1.
:-#count{X:move(X,_)}<1.

%SE è POSSIBILE MUOVERE IL BLOCCO 0 VA MOSSO.
:~move(X,_),X<>0.[1@10]

%PAGO PER OGNI BLOCCO DI DISTANZA DAL BLOCCO DELLA VITTORIA, COSI SE POSSO MUOVERE LO 0 IN 2 POSIZIONI SCELGO QUELLA PIU VICINA AL PUNTO D USCITA
distanceFromWin(T):-winPosition(P,L),blocco(_, X, Y, 1, 2, 2),I=P-X,J=L-Y,T=I+J.
:~distanceFromWin(T).[T@9]

%SE NON è POSSIBILE MUOVERE IL BLOCCO 0, è PREFERIBILE MUOVERE UN BLOCCO CHE SI TROVA SOTTO AL BLOCCO 0 COSI DA PROVARE A SBLOCCARLO.
isBlocking(ID):-blocco(0,_, X, Y1, _, _),canMoveDown(ID),blocco(T,ID,X,Y2,_,_),Y2=Y1+1,winPosition(X,_),T>0.
isBlocking(ID):-blocco(0,_, X, Y1, _, _),canMoveLeft(ID),blocco(T,ID,X,Y2,_,_),Y2=Y1+1,winPosition(X,_),T>0.
isBlocking(ID):-blocco(0,_, X, Y1, _, _),canMoveRight(ID),blocco(T,ID,X,Y2,_,_),Y2=Y1+1,winPosition(X,_),T>0.

%SE NON è POSSIBILE MUOVERE IL BLOCCO 0, è PREFERIBILE MUOVERE UN BLOCCO CHE SI TROVA A DESTRA DEL BLOCCO 0 COSI DA PROVARE A SBLOCCARLO.
isBlocking(ID):-blocco(0,_, X1, Y, _, _),canMoveDown(ID),blocco(T,ID,X2,Y,_,_),X2=X1+1,winPosition(_,Y),T>0.
isBlocking(ID):-blocco(0,_, X1, Y, _, _),canMoveUp(ID),blocco(T,ID,X2,Y,_,_),X2=X1+1,winPosition(_,Y),T>0.
isBlocking(ID):-blocco(0,_, X1, Y, _, _),canMoveLeft(ID),blocco(T,ID,X2,Y,_,_),X2=X1+1,winPosition(_,Y),T>0.

%SE NON è POSSIBILE MUOVERE IL BLOCCO 0, è PREFERIBILE MUOVERE UN BLOCCO CHE SI TROVA A SINISTRA DEL BLOCCO 0 COSI DA PROVARE A SBLOCCARLO.
isBlocking(ID):-blocco(0,_, X1, Y, _, _),canMoveDown(ID),blocco(T,ID,X2,Y,_,_),X2=X1-1,winPosition(_,Y),T>0.
isBlocking(ID):-blocco(0,_, X1, Y, _, _),canMoveUp(ID),blocco(T,ID,X2,Y,_,_),X2=X1-1,winPosition(_,Y),T>0.
isBlocking(ID):-blocco(0,_, X1, Y, _, _),canMoveRight(ID),blocco(T,ID,X2,Y,_,_),X2=X1-1,winPosition(_,Y),T>0.

:~isBlocking(X),X<>0.[1@8]
%NON è POSSIBILE FARE LA MOSSA INVERSA DEL TURNO PRECEDENTE. EVITA CICLI. MOVED VIENE AGGIUNTO DA JAVA AL TERMITE DI OGNI MOSSA.
:-moved(X,1),move(X,2). 
:-moved(X,2),move(X,1).
:-moved(X,3),move(X,4).
:-moved(X,4),move(X,3).
